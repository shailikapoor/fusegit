{"name":"FuseGit","tagline":"a FUSE filesystem based on Git object database as its backend.","note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","body":"[Home](http://agrawal-varun.com)\r\n\r\nFuseGit\r\n=======\r\n\r\nA FUSE file system with Git as the backend. Git is known to be a file system \r\nin itself. So what is different in 'FuseGit'.\r\n\r\nFuseGit is a file system first, and has the features of Git at its backend. So \r\nif you modified a file and want to revert back. There is a backup waiting for \r\nyou. If you keep taking snapshots of your file system, then it becomes \r\nextremely easy for FuseGit to revert you back in time. But, if you didn't name \r\nit, it will still keep taking snapshots regularly. And you can choose your \r\ntime from the list provided to you.\r\n\r\nAll this sounds non-magical if you are familiar with Git or any other version \r\ncontrol system. But for people who don't want the added complexity of playing \r\nwith a VCS, FuseGit will give a ready to use recipe. Just plug it in. And have \r\nregular backups of your file system, without worrying about too much memory \r\nbeing consumed.\r\n\r\nCleaning up\r\n-----------\r\nHave you ever looked at the Linux repository? If you do a clone of the \r\nrepository, it will be several multiples of the actual filesize. This is \r\nbecause they are storing every possible content. This is a common issue with \r\nany VCS, it grows in size with time more than the actual content. This can be \r\nhandled if you take care to clean up the history markers at regular intervals.\r\n\r\nImplementation\r\n--------------\r\n`FUSE` is in the name, so we are obviously using it. This means that the file \r\nsystem is in user space. This is a prototype version and we want to keep \r\nthings simple.\r\n\r\n`libgit2` will be used to get the Git functionality. This library is still \r\nunder active development. I hope we don't end up requiring a feature which is \r\nstill under development. This is a risk we might have to take right now.\r\n\r\n### libgit2\r\n1. Create a repository.\r\n2. If its a new repository, find the global configuration path in the system, \r\nand apply it to this repository using `git_config_find_global` and `git_config_add_file_ondisk`.\r\n3. To add a new file to the repository:\r\n\t1. Create a blob from the file.\r\n\t2. Create a signature for the author and committer.\r\n\t3. Create a treebuilder, and add the blob to the tree.\r\n\t4. Multiple files could be added to this treebuilder.\r\n\t5. Once the tree is obtained, commit it to the repository.\r\n\r\n### FUSE\r\nTODO\r\n"}